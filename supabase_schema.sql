-- Create Profiles Table (if not exists)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  full_name text,
  avatar_url text,
  university text,
  program text,
  gpa numeric(4, 2),
  credits_earned numeric(5, 1),
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

-- Remove Attendance Column if it still exists (cleanup)
alter table public.profiles drop column if exists attendance_percentage;

-- Create Classes Table (if not exists)
create table if not exists public.classes (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  subject_name text not null,
  subject_code text,
  type text check (type in ('theory', 'lab')),
  slot_code text,
  slot_label text,
  day text not null,
  start_time time not null,
  end_time time not null,
  room text,
  credit numeric(3, 1),
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Create Tasks Table (if not exists)
create table if not exists public.tasks (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text not null,
  due_date timestamp with time zone,
  is_completed boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Create Skills Table (if not exists)
create table if not exists public.skills (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text not null,
  progress integer default 0 check (progress >= 0 and progress <= 100),
  category text, 
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Enable RLS (safe to run multiple times)
alter table public.profiles enable row level security;
alter table public.classes enable row level security;
alter table public.tasks enable row level security;
alter table public.skills enable row level security;

-- Create Policies (Idempotent approach using DO blocks)
do $$
begin
  if not exists (select 1 from pg_policies where policyname = 'Users can view own profile') then
    create policy "Users can view own profile" on public.profiles for select using (auth.uid() = id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can update own profile') then
    create policy "Users can update own profile" on public.profiles for update using (auth.uid() = id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can insert own profile') then
    create policy "Users can insert own profile" on public.profiles for insert with check (auth.uid() = id);
  end if;
  
  if not exists (select 1 from pg_policies where policyname = 'Users can view own classes') then
    create policy "Users can view own classes" on public.classes for select using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can insert own classes') then
    create policy "Users can insert own classes" on public.classes for insert with check (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can update own classes') then
    create policy "Users can update own classes" on public.classes for update using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can delete own classes') then
    create policy "Users can delete own classes" on public.classes for delete using (auth.uid() = user_id);
  end if;

  if not exists (select 1 from pg_policies where policyname = 'Users can view own tasks') then
    create policy "Users can view own tasks" on public.tasks for select using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can insert own tasks') then
    create policy "Users can insert own tasks" on public.tasks for insert with check (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can update own tasks') then
    create policy "Users can update own tasks" on public.tasks for update using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can delete own tasks') then
    create policy "Users can delete own tasks" on public.tasks for delete using (auth.uid() = user_id);
  end if;
  
  -- Skills Policies
  if not exists (select 1 from pg_policies where policyname = 'Users can view own skills') then
    create policy "Users can view own skills" on public.skills for select using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can insert own skills') then
    create policy "Users can insert own skills" on public.skills for insert with check (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can update own skills') then
    create policy "Users can update own skills" on public.skills for update using (auth.uid() = user_id);
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Users can delete own skills') then
    create policy "Users can delete own skills" on public.skills for delete using (auth.uid() = user_id);
  end if;
end
$$;

-- Trigger for new user handling (Safe to replace)
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname = 'on_auth_user_created') then
    create trigger on_auth_user_created
      after insert on auth.users
      for each row execute procedure public.handle_new_user();
  end if;
end
$$;

-- Storage Setup (Idempotent)
insert into storage.buckets (id, name, public) 
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

do $$
begin
  if not exists (select 1 from pg_policies where policyname = 'Avatar images are publicly accessible') then
    create policy "Avatar images are publicly accessible" on storage.objects for select using ( bucket_id = 'avatars' );
  end if;
  if not exists (select 1 from pg_policies where policyname = 'Anyone can upload an avatar') then
    create policy "Anyone can upload an avatar" on storage.objects for insert with check ( bucket_id = 'avatars' );
  end if;
end
$$;

-- Optional: Storage Bucket for Avatars --
-- insert into storage.buckets (id, name) values ('avatars', 'avatars');
-- create policy "Avatar images are publicly accessible" on storage.objects for select using ( bucket_id = 'avatars' );
-- create policy "Anyone can upload an avatar" on storage.objects for insert with check ( bucket_id = 'avatars' );
